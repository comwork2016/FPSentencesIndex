 本文为论文《Winnowing: Local Algorithms for Document Fingerprinting》的读书笔记。 
14723927527537152	本文	论文	winnowing	local	algorithms	document	[1,59]
457640403428848542	winnowing	local	algorithms	document	fingerprinting	读书	[19,86]


       在当今时代，电子内容会通过很多途径出现相同的情况，比如说：引用，版本修订，剽窃等。
12312349656048	当今	时代	电子	内容	会	通过	[108,144]
17686348711488	途径	出现	相同	情况	比如说	引用	[150,198]
154628956656720	比如说	引用	版本	修订	剽窃	等	[180,225]


而文档指纹是用来准确指定拷贝的有效途径，哪怕是在大量的文档集合种有小部分的拷贝。
13241033624592	文档	指纹	用来	准确	指定	拷贝	[231,270]
14775849158976	用来	准确	指定	拷贝	有效	途径	[246,285]
12851825448816	指定	拷贝	有效	途径	哪怕	大量	[258,306]
17673263151696	途径	哪怕	大量	文档	集合	种	[279,324]
13596123724560	文档	集合	种	有小	部分	拷贝	[309,345]


       在该论文中，作者介绍了通用的文档指纹算法，这些算法似乎可以捕捉到任何指纹的通用属性来保证拷贝的检测。
16446884346864	论文	中	作者	介绍	通用	文档	[362,404]
18040868943696	通用	文档	指纹	算法	这些	算法	[389,431]
13403672647056	指纹	算法	这些	算法	似乎	可以	[404,443]
12724011991440	捕捉	任何	指纹	通用	属性	保证	[443,488]
13557475644912	指纹	通用	属性	保证	拷贝	检测	[458,503]


另外，作者还提出了一种新的效果卓越的算法，名称是“Winnowing”。
10817340174720	一种	新的	效果	卓越	算法	名称	[533,575]


该算法对于文档指纹的侦测非常高效。
15597989612352	算法	对于	文档	指纹	侦测	非常	[599,638]


       作者首先从背景入手，讲述了文档抄袭检测的实际意义。
16062346712304	背景	入手	讲述	文档	抄袭	检测	[671,713]


关于文档的抄袭，不仅仅是大篇幅的引用或剽窃，同时还包括小部分的拷贝，而后者更加隐蔽，且不会轻易被发现，但是现在后者这种现象已经受到广泛的关注，有很多的研究在尝试解决后者这个难题。 
13211680900176	文档	抄袭	不仅	仅是	大	篇幅	[737,776]
9783887965344	仅是	大	篇幅	引用	剽窃	同时	[761,803]
15538254219360	篇幅	引用	剽窃	同时	还包括	小部分	[770,821]
12522513285648	剽窃	同时	还包括	小部分	拷贝	后者	[788,842]
211666179937104	还包括	小部分	拷贝	后者	更加	隐蔽	[803,854]
13151610898272	拷贝	后者	更加	隐蔽	且不	会	[824,866]
18586526246640	隐蔽	且不	会	轻易	发现	但是	[848,890]
17662764435408	轻易	发现	但是	现在	后者	这种	[866,908]
11943834243696	后者	这种	现象	已经	受到	广泛	[896,932]
11334463149456	关注	很多	研究|琢磨|研讨|钻研	尝试	解决	后者	[935,983]
61274455588224	研究|琢磨|研讨|钻研	尝试	解决	后者	这个	难题	[956,995]


       之前很多的检测算法都利用了一个观点，那就是k-gram，长度为k的连续子串。
10413066028032	之前	很多	检测	算法	都	利用	[1007,1043]
13765407613200	检测	算法	都	利用	一个	观点	[1022,1058]
16825701951504	那就	k	gram	长度	k	连续	[1061,1098]


这些算法，首先将文档分成很多个k-grams，而这个k值是用户指定的。
16086872860704	算法	首先	将	文档	分成	多个	[1113,1152]
13037759943840	文档	分成	多个	k	grams	这个	[1131,1171]
11119082835456	多个	k	grams	这个	k	值	[1146,1175]
85520350015776	grams	这个	k	值	用户	指定	[1154,1190]


然后再哈希每一个k-gram，最后选出这些哈希值的一些子集，作为这个文档的指纹。
22842048038112	哈希	每一个	k	gram	最后	选出	[1205,1241]
682648939008	k	gram	最后	选出	这些	哈希	[1220,1253]
18057994059168	选出	这些	哈希	值	一些	子集	[1235,1271]
10328112283104	哈希	值	一些	子集	作为	这个	[1247,1286]


在所有的实用的算法中，指纹还带有位置信息，这些信息代表着这些指纹来自的文档位置。
12388879204704	实用	算法	中	指纹	带有	位置	[1316,1358]
13080438595440	指纹	带有	位置	信息	这些	信息	[1337,1379]


这里需要注意的是，如果在实际过程中，一旦hash函数被选定的话，那么两个不同文档冲突的概率会非常小，这样也就大大降低了偶然性，反过来讲，一旦两个文档的文档指纹是一样的，那么非常可能这两个文档使用的是同一个k-gram。 
204915624397776	过程中	一旦	hash	函数	选定	的话	[1466,1509]
7947762010272	hash	函数	选定	的话	那么	两个	[1484,1524]
18010462637808	选定	的话	那么	两个	不同	文档	[1497,1536]
10189276835040	两个	不同	文档	冲突	概率	会	[1518,1554]
13065560755632	文档	冲突	概率	会	非常	这样	[1530,1572]
12866004776160	概率	会	非常	这样	大大	降低	[1545,1590]
12975177887712	大大	降低	偶然性	反过来	讲	一旦	[1578,1626]
130262086317168	偶然性	反过来	讲	一旦	两个	文档	[1593,1638]
10389011927472	一旦	两个	文档	文档	指纹	一样	[1620,1662]
13234451424768	文档	文档	指纹	一样	那么	非常	[1632,1680]
12984269346144	指纹	一样	那么	非常	可能	两个	[1647,1695]
10467336425040	两个	文档	使用	同一个	k	gram	[1689,1728]


       可见，为了效率而言，并没有将所有的hash值作为文档的指纹，而是选取了其中的一部分来作为文档指纹。
14445515829888	效率	而言	并没有	将	所有	hash	[1755,1795]
137832436181664	并没有	将	所有	hash	值	作为	[1770,1804]
7127721116208	hash	值	作为	文档	指纹	而是	[1791,1828]
13253386300704	文档	指纹	而是	选取	其中	一部分	[1804,1855]
18268319075472	选取	其中	一部分	作为	文档	指纹	[1828,1876]


那么这里就会存在一个如何选择hash值的问题，这个问题也是本文的一个关键点，好的选择策略可以使得算法的效率高，可用性高，并且干扰噪声小。
11849668970112	就会	存在	一个	如何	选择	hash	[1891,1925]
7189230439152	hash	值	问题	这个	问题	本文	[1921,1964]
13136177014992	本文	一个	关键	点	好的	选择	[1958,1997]
10506534027984	关键	点	好的	选择	策略	可以	[1973,2009]
12442468119120	好的	选择	策略	可以	使得	算法	[1985,2021]
15565817674224	策略	可以	使得	算法	效率高	用性	[1997,2045]
11879580586176	使得	算法	效率高	用性	高	并且	[2009,2057]
149084915909760	效率高	用性	高	并且	干扰	噪声	[2024,2069]


在选择策略中，有一种方法是之前被广泛使用的，那就是0 mod p，而这个p值是被用户指定的。
14787792245808	策略	中	一种	方法	之前	广泛	[2084,2129]
10791663992784	一种	方法	之前	广泛	使用	那就	[2099,2147]
10401017351040	之前	广泛	使用	那就	0	mod	[2114,2155]
16771804599168	那就	0	mod	p	这个	p	[2141,2170]
729092889072	mod	p	这个	p	值	用户	[2152,2185]


这样的方法是很容易实现，因为这使得所有的hash值中的1/p被保留下来作为文档指纹。
138226699633536	很容易	实现	因为	使得	所有	hash	[2215,2261]
10656424159056	使得	所有	hash	值	中	1	[2242,2271]
7059431827152	hash	值	中	1	p	保留	[2257,2282]
76638707568	1	p	保留	下来	作为	文档	[2270,2300]


而作为检测文档间是否存在雷同的方法，就是检测文档指纹相同指纹的个数。
13561127668224	检测	文档	间	是否	存在	雷同	[2318,2351]
18489616259472	雷同	方法	就是	检测	文档	指纹	[2345,2387]
13636440963648	检测	文档	指纹	相同	指纹	个数	[2369,2408]



10518198768144	会有	一个	弊端	那就	不能	保证	[2441,2483]
13060633580928	弊端	那就	不能	保证	文档	间	[2453,2492]
10699740827856	不能	保证	文档	间	所有	匹配	[2471,2507]
12336083942256	文档	间	所有	匹配	会被	检测	[2483,2519]
11417008631184	匹配	会被	检测	出来	因为	所有	[2501,2546]
13442940316944	检测	出来	因为	所有	选择	都	[2513,2558]
1159814071728000	本文	提出	方法	winnowing	可以	hash	[2580,2626]
443859677215330956	winnowing	可以	hash	序列	种	选取	[2601,2641]
7941168627840	hash	序列	种	选取	合适	集合	[2622,2656]
2586546106992	种	选取	合适	集合	作为	文档	[2632,2668]
12091306573440	合适	集合	作为	文档	指纹	并且	[2641,2683]
13221898601328	文档	指纹	并且	可以	保证	任意	[2662,2701]
9674013244176	任意	总	够	长的	匹配	都	[2695,2722]
2353589157744	够	长的	匹配	都	会被	检测	[2704,2734]
443860808329344876	winnowing	算法	之所以	会	这样	高效	[2749,2791]
115144099788960	之所以	会	这样	高效	因为	选取	[2764,2812]
18949813102080	高效	因为	选取	hash	值	集合	[2785,2825]
17222300910720	选取	hash	值	集合	时候	采用	[2806,2843]
2276835822576	值	集合	时候	采用	滑动	窗	[2816,2855]
21019306549824	滑动	窗	window	概念	选取	hash	[2846,2889]
1147571444668608	window	概念	选取	hash	值	使用	[2858,2901]
17217972970992	选取	hash	值	使用	滑动	窗口	[2879,2913]
1653839989776	值	使用	滑动	窗口	选择	指纹	[2889,2928]
14268932024400	滑动	窗口	选择	指纹	好处	指纹	[2901,2949]
13052843100000	指纹	好处	指纹	选择	更多的	依赖于	[2922,2976]
14550731457552	指纹	选择	更多的	依赖于	窗口	内	[2943,2985]
157105987803072	更多的	依赖于	窗口	内	hash	值	[2958,2995]
14375484213552	窗口	内	hash	值	序列	但是	[2976,3010]
7137516786048	hash	值	序列	但是	0	mod	[2988,3015]
11967288093648	序列	但是	0	mod	p	选择	[2995,3023]
62685900576	0	mod	p	选择	时	更多	[3010,3035]
1420182619776	p	选择	时	更多	取决于	0	[3016,3045]
2784284017920	时	更多	取决于	0	mod	p	[3023,3051]
115557935357520	也就是	在最	原始	hash	值	中	[3060,3094]
10617115359168	原始	hash	值	中	作者	首先	[3075,3109]
875507805936	值	中	作者	首先	窗口	大小	[3088,3124]
15162349033584	窗口	大小	w	选择	这个	窗口	[3112,3146]
1524374271792	w	选择	这个	窗口	中	最小	[3124,3155]
14412096383328	窗口	中	最小	hash	值	然后	[3140,3174]
12777838239456	最小	hash	值	然后	将	这个	[3149,3183]
1854883499184	值	然后	将	这个	窗口	向右	[3162,3195]
15206083401168	窗口	向右	移动	移动	一个	都	[3183,3225]
15433527058272	移动	移动	一个	都	选择	出	[3195,3234]
15086311702848	结束	会	选择	出	很多	hash	[3277,3314]
7128220387248	hash	值	但是	可以	预见	这些	[3310,3356]
19480491184032	预见	这些	hash	值	中	肯定	[3332,3375]
7068153106944	hash	值	中	肯定	会	存在	[3356,3384]
15148267361280	肯定	会	存在	很多	相邻	hash	[3369,3403]
15019869145824	相邻	hash	值	相同	这是	因为	[3390,3433]
2014682587776	值	相同	这是	因为	窗口	滑动	[3403,3445]
11300892959232	再将	这些	相同	hash	值	进行	[3463,3497]
7179973716672	hash	值	进行	处理	最后	得到	[3484,3518]
15143452116336	hash	值	集合	就是	使用	winnowing	[3545,3585]
1164822541703568	集合	就是	使用	winnowing	文档	指纹	[3552,3603]
26814125479104	算法	有一些	文档	那个	不适	用的	[3630,3675]
13604063622048	文档	那个	不适	用的	比如说	整个	[3648,3693]
12151641906000	不适	用的	比如说	整个	文档	中都	[3663,3705]
154653187922208	比如说	整个	文档	中都	同一个	字符	[3678,3723]
15211201123728	的话	几乎	产生	hash	值	只有	[3747,3784]
7130586475440	hash	值	只有	一个	将	大大	[3771,3808]
18245678111280	随后	作者	介绍	文档	相似	检测	[3850,3895]
13382775058608	文档	相似	检测	领域	一些	背景	[3877,3916]
14073787869120	检测	领域	一些	背景	相关	性工作	[3889,3934]
1404117660240	要	对	一个	文档	进行	指纹	[3961,3991]
13648283713152	文档	进行	指纹	提取	的话	那么	[3973,4012]
13152525099984	指纹	提取	的话	那么	这个	指纹	[3985,4024]
15837730458768	的话	那么	这个	指纹	提取	算法	[3997,4036]
13151512787184	指纹	提取	算法	必须	满足	3	[4018,4049]
14779310245488	算法	对	空格	具有	不敏	感性	[4073,4106]
1376716618522656	也就是说	对	文档	初步	处理	会	[4109,4151]
13161744199152	文档	初步	处理	会	采取措施	使得	[4127,4172]
2434224816637776	采取措施	使得	文档	中	空格	标点	[4151,4196]
12300526416960	文档	中	空格	标点	等	个数	[4172,4208]
15491637436752	空格	标点	等	个数	对	初步	[4181,4217]
1937665524096	等	个数	对	初步	处理	结果	[4196,4229]
11038575446208	初步	处理	结果	不具	有影	响的	[4211,4250]
15733374388272	算法	本身	具有	噪声	抑制	特性	[4262,4301]
14169168010368	比如	这样	单词	文档	间	出现	[4331,4379]
11481763640112	单词	文档	间	出现	然	后被	[4355,4391]
11622990102192	匹配	方面	匹配	必须	足够	长	[4436,4472]
11603961136368	匹配	必须	足够	长	使得	这样	[4451,4487]
16606484792784	足够	长	使得	这样	匹配	可以	[4463,4502]
11106116720496	使得	这样	匹配	可以	预示	文档	[4475,4517]
11455273506528	匹配	可以	预示	文档	间	的确	[4490,4526]
18929621721168	预示	文档	间	的确	存在	抄袭	[4502,4538]
15146689137552	的确	存在	抄袭	或者	雷同	现象	[4520,4556]
154432757552832	比如说	不同	文档	间	出现	相同	[4571,4613]
12326740754400	文档	间	出现	相同	谚语	虽然	[4589,4631]
18152050588272	谚语	虽然	谚语	长度	可能	足够	[4616,4658]
18230905178928	谚语	长度	可能	足够	长	但是	[4631,4670]
16663449414816	足够	长	但是	不应该	凭此	认为	[4652,4697]
115743981299328	不应该	凭此	认为	文档	间	存在	[4670,4712]
15688049041440	算法	文档	内容	位置	存在	依赖	[4730,4775]
154434983267520	比如说	两个	文档	已经	存在	相似	[4784,4826]
13175994957696	文档	已经	存在	相似	现象	那么	[4802,4841]
15179131343232	相似	现象	那么	在其中	一篇	文章	[4820,4862]
125705531567088	在其中	一篇	文章	中	插入	某些	[4841,4877]
12451664733840	文章	中	插入	某些	成段	内容	[4856,4889]
12834759634272	插入	某些	成段	内容	将不	会	[4865,4898]
12676458600576	成段	内容	将不	会	影响	原先	[4877,4913]
10990717063776	将不	会	影响	原先	相似	度	[4889,4925]
11521050170256	删除	某些	无关	内容	不会	影响	[4940,4982]
12850829615808	无关	内容	不会	影响	最终	相似	[4955,5000]
173138376085200	第一个	特性	对	文档	进行	简单	[5027,5066]
13780055547072	文档	进行	简单	预处理	即可	做到	[5048,5093]
213227531065008	预处理	即可	做到	该文	没有	大	[5069,5114]
11050317771840	做到	该文	没有	大	篇幅	讲述	[5087,5126]
173307103679520	第二个	特性	讲述	作者	提出	一个	[5144,5192]
17610940126800	讲述	作者	提出	一个	阈值	概念	[5162,5204]
27862528022640	阈值	概念	也就是说	需要	选择	足够	[5192,5237]
1378172703017664	也就是说	需要	选择	足够	长的	值	[5207,5249]
17882646627744	足够	长的	值	k	使得	这个	[5231,5265]
812743073280	值	k	使得	这个	k	值	[5246,5269]
11007780700752	使得	这个	k	值	普通	谚语	[5253,5287]
163151918352	k	值	普通	谚语	长度	要	[5265,5296]
14838789586464	用的	一个	假设	这个	假设	长度	[5314,5356]
11578472410032	假设	这个	假设	长度	小于	k	[5326,5366]
11638008852624	假设	长度	小于	k	子串	匹配	[5341,5381]
10942312873824	小于	k	子串	匹配	有意义	长度	[5359,5408]
12677863694256	子串	匹配	有意义	长度	小于	k	[5369,5415]
149020994728080	有意义	长度	小于	k	子串	匹配	[5384,5430]
10936173090960	小于	k	子串	匹配	不具	有意义	[5408,5448]
10557588446352	三个	特性	讲述	非常	有趣	有意义	[5472,5526]
18331849581408	讲述	非常	有趣	有意义	达到	这个	[5487,5547]
25058025046224	有趣	有意义	达到	这个	特性	时候	[5505,5562]
14554139138640	特性	时候	作者	介绍	一种	之前	[5547,5592]
10569824269632	一种	之前	广泛	使用	策略	karp	[5580,5623]
14891386425264	karp	rabin	算法	为了	实现	快速	[5654,5691]
15464932208784	算法	为了	实现	快速	子串	匹配	[5664,5703]
7149223395360	hash	值	时候	主要	呈现出	一个	[5718,5761]
7263956697696	hash	值	计算	特殊性	前	一个	[5791,5828]
164059119972864	特殊性	前	一个	hash	计算	值	[5807,5841]
8379623732544	hash	计算	值	其实	一个	hash	[5828,5863]
1622704144896	值	其实	一个	hash	计算	值	[5838,5872]
8388113089248	hash	计算	值	很大	相似性	因为	[5859,5902]
2844446465376	值	很大	相似性	因为	前	一个	[5869,5911]
167618175314400	相似性	因为	前	一个	计算	一个	[5884,5929]
11348926106112	后者	利用	前者	有的	计算	值	[5992,6028]
11385253523376	前者	有的	计算	值	进行	计算	[6004,6040]
2284439423184	值	进行	计算	计算	只是	前者	[6025,6070]
11713390614864	前者	计算	结果	多	两个	加法	[6064,6103]
1673996237712	多	两个	加法	计算	两次	乘法	[6088,6124]
11541527108208	加法	计算	两次	乘法	计算	大大	[6097,6139]
10507508809200	两次	乘法	计算	大大	降低	原始	[6112,6154]
12151092773808	大大	降低	原始	计算	计算	复杂性	[6133,6178]
18714474163584	随后	论文	中	作者	描述	分析	[6190,6232]
13770699154889616	描述	分析	winnowing	算法	其实	可以	[6217,6268]
443860083147514812	winnowing	算法	其实	可以	发现	算法	[6235,6286]
10497704161824	关键	点	如何	k	grams	众多	[6295,6332]
7085714738256	k	grams	众多	hash	值	种	[6316,6342]
10112528199168	众多	hash	值	种	选出	最终	[6326,6354]
29614433191056	检测	过程中	作者	希望	子串	匹配	[6369,6414]
13068450763056	子串	匹配	过程中	满足	两个	特性	[6399,6441]
205265014647552	过程中	满足	两个	特性	1	如果	[6414,6454]
10448655295392	两个	特性	1	如果	一个	子串	[6429,6466]
973416771936	1	如果	一个	子串	匹配	长度	[6444,6481]
11772149557392	子串	匹配	长度	至少	受	保证	[6460,6499]
18598429470528	长度	至少	受	保证	阈值	t	[6475,6509]
17360835415920	阈值	t	的话	这样	匹配	会被	[6502,6539]
15807052949904	的话	这样	匹配	会被	检测	出来	[6509,6551]
1284610572576	2	算法	不会	检	测出	长度	[6554,6585]
2152697153616	检	测出	长度	小于	k	匹配	[6570,6601]
18235428056496	长度	小于	k	匹配	这个	k	[6579,6611]
994058336160	k	匹配	这个	k	值	被称为	[6591,6623]
1480281877296	k	越大	的话	那么	越有	信心	[6668,6708]
15836377695408	的话	那么	越有	信心	证明	检测	[6675,6720]
17452124873424	越有	信心	证明	检测	出来	匹配	[6696,6735]
443858975659048956	winnowing	中	选择	文档	指纹	时候	[6759,6798]
13228254216864	文档	指纹	时候	如果	出现	很多	[6777,6822]
16609440708720	相邻	相同	最小值	那么	选择	右端	[6822,6870]
148431992062176	最小值	那么	选择	右端	出现	那个	[6837,6885]
11325388404672	右端	出现	那个	值	最后	保存	[6864,6903]
1819571988240	值	最后	保存	所有	选择	出来	[6885,6924]
10731383621568	保存	所有	选择	出来	hash	值	[6897,6934]
16104072594384	算法	运用	时候	虽然	指纹	可以	[6979,7024]
12985264769904	指纹	可以	按照	算法	获取	但是	[7012,7051]
15948273077424	算法	获取	但是	具体	算法	流程	[7030,7072]
15709061682432	算法	流程	中	可能	会	存在	[7060,7093]
14502722289408	效率	问题	也就是	如何	使得	hash	[7099,7139]
115558665668496	也就是	如何	使得	hash	值	一次	[7114,7151]
2304801990432	值	都是	存放	数据库	中	然后	[7172,7217]
23146986535056	存放	数据库	中	然后	这些	指纹	[7184,7229]
13762429101504	我们	采取	另一个	窗口	fw	实现	[7250,7288]
121320138589200	另一个	窗口	fw	实现	对	指纹	[7262,7297]
990659767824	fw	实现	对	指纹	选择	的话	[7277,7309]
13569707749824	指纹	选择	的话	那么	这样	实现	[7291,7333]
15838870524048	的话	那么	这样	实现	流程	中	[7303,7342]
13280079156768	流程	中	使用	内存	磁盘	访问	[7333,7372]
11126978580096	内存	磁盘	访问	会	变得	更	[7351,7384]
16889129174016	访问	会	变得	更	少	更	[7366,7393]
10198159940304	变得	更	少	更	有利于	指纹	[7375,7408]
17321171539248	论文	后面	部分	作者	使用	一系列	[7435,7483]
214129280567376	一系列	实验	数据	检验	winnowing	算法	[7474,7522]
13775675243315472	c语言	展现	winnowing	算法	具体	代码	[7534,7580]
273
9907978649744
