       当然这样的算法也有一些文档那个是不适用的，比如说整个文档中都是同一个字符的文档。因为这样的话，几乎产生的hash值只有一个，而这将大大降低文档指纹的代表性。 
       随后作者还介绍了在文档相似检测领域的一些背景和相关性工作。 
       首先，如果要对一个文档进行指纹提取的话，那么这个指纹提取算法必须满足3个特性。第一，该算法对空格具有不敏感性。也就是说，对文档的初步处理会采取措施，使得文档中空格，标点等的个数对初步处理结果是不具有影响的。第二，算法本身具有噪声抑制的特性。首先需要注意的是，比如“the”这样的单词在文档间出现，然后被检测出来，是没有意义的。所以在匹配方面，匹配必须足够长，使得这样的匹配可以预示着文档间的确存在抄袭或者雷同现象。同样的，比如说在不同文档间出现了相同的谚语，虽然谚语的长度可能足够长，但是不应该就凭此就认为文档间存在雷同。第三，算法与文档内容的位置不存在依赖关系。比如说，两个文档已经存在相似现象，那么在其中一篇文章中插入某些成段内容将不会影响到原先的相似度结果；或者删除了某些无关内容也不会影响到最终的相似度结果。 
       关于第一个特性，对文档进行简单的预处理即可以做到，该文也没有大篇幅讲述。 
       但是第二个特性的讲述，作者提出了一个阈值概念，也就是说需要选择足够长的的值k，使得这个k值比普通的谚语长度要长。所以这里用的一个假设，这个假设是长度不小于k的子串匹配是有意义的，而长度小于k的子串匹配是不具有意义的。 
       其实第三个特性的讲述，是非常有趣也是有意义的，为达到这个特性的时候，作者介绍了一种之前也被广泛使用的策略Karp-Rabin String Match。 
       Karp-Rabin算法是为了实现快速子串匹配的。在计算hash值的时候，主要是呈现出一个多项式计算。但是由于hash值计算的特殊性，前一个hash计算值其实和后一个hash计算值有很大的相似性，因为前一个计算和后一个计算在本质上只是相差一个字符。所以可以采用后者利用前者已有的计算值进行计算，在计算上只是在前者的计算结果上多两个加法计算和两次乘法计算，大大降低了原始计算的计算复杂性。 
       随后的论文中，作者描述和分析了winnowing算法，其实也可以发现，该算法的主要关键点是如何从k-grams的众多hash值种选出最终的指纹。在检测过程中，作者希望子串在匹配过程中满足两个特性：1，如果一个子串匹配的长度至少是受保证的阈值t的话，这样的匹配会被检测出来；2，算法不会检测出长度小于k的匹配，这个k值被称为噪声阈值。 
       可以看到，如果k越大的话，那么我就越有信心证明检测出来的匹配不是偶然性的。在winnowing中选择文档指纹的时候，如果出现了很多相邻的相同最小值，那么选择最右端出现的那个值，最后保存所有被选择出来的hash值作为文档的指纹。 
       关于在本算法在运用的时候，虽然指纹可以按照算法获取，但是在具体算法流程中，可能会存在一个效率问题，也就是如何使得hash值被一次选出。首先这些值都是被存放在数据库中的，然后这些指纹会被索引。如果我们采取另一个窗口Fw来实现对指纹选择的话，那么这样在实现流程中使用的内存和磁盘访问会变得更少，更有利于指纹的查找。 
       在该论文的后面部分，作者使用了一系列的实验数据来检验winnowing算法。以及以C语言展现了winnowing算法的具体代码实现。
